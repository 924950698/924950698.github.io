(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{378:function(v,_,t){"use strict";t.r(_);var i=t(10),e=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"渲染篇-浏览器端渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#渲染篇-浏览器端渲染"}},[v._v("#")]),v._v(" 渲染篇 - 浏览器端渲染")]),v._v(" "),_("p",[_("b",[v._v(" 浏览器的内核 ")])]),v._v(" "),_("p",[v._v("前端工程师免不了需要去处理不同浏览器下代码渲染结果的差异性。这些差异性正是因为浏览器内核的不同而导致的——浏览器内核决定了浏览器解释网页语法的方式。")]),v._v(" "),_("p",[v._v("浏览器内核可以分成两部分：渲染引擎（Layout Engine 或者 Rendering Engine）和 JS 引擎。早期渲染引擎和 JS 引擎并没有十分明确的区分，但随着 JS 引擎越来越独立，内核也成了渲染引擎的代称（下文我们将沿用这种叫法）。渲染引擎又包括了 HTML 解释器、CSS 解释器、布局、网络、存储、图形、音视频、图片解码器等等零部件。")]),v._v(" "),_("p",[v._v("目前市面上常见的浏览器内核可以分为这四种：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://i.loli.net/2020/03/13/RuBxWIeZ2PzGjig.png",alt:"微信图片_20200313170601.png"}})]),v._v(" "),_("p",[v._v("做开发的同学应该对Webkit内核听的最多了，因为chrome就是Webkit内核，但是Chrome内核已经迭代为Blink。其实也是Webkit衍生的一个分支，当下Webkit仍然是霸主。")]),v._v(" "),_("h3",[v._v(" 浏览器如何渲染页面？ ")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://i.loli.net/2020/03/13/1CgzEtRMU7Sxcm2.png",alt:"微信图片_20200313171523.png"}})]),v._v(" "),_("p",[v._v("从图中来看，"),_("b",[v._v("浏览器内核")]),v._v(" 类似一个加工厂的作用，将接收到的原材料（HTML/CSS/JS资源）通过各种加工工具给解析成“图像”。各种工具就是各种模块，包括："),_("b",[v._v(" HTML 解释器、CSS 解释器、图层布局计算模块、视图绘制模块与JavaScript 引擎 ")]),v._v("这几大模块：")]),v._v(" "),_("ol",[_("li",[v._v("HTML 解释器：将 HTML 文档经过词法分析输出 DOM 树。")]),v._v(" "),_("li",[v._v("CSS 解释器：解析 CSS 文档, 生成样式规则。")]),v._v(" "),_("li",[v._v("图层布局计算模块：布局计算每个对象的精确位置和大小。")]),v._v(" "),_("li",[v._v("视图绘制模块：进行具体节点的图像绘制，将像素渲染到屏幕上。")]),v._v(" "),_("li",[v._v("JavaScript 引擎：编译执行 Javascript 代码。")])]),v._v(" "),_("h3",[v._v(" 浏览器渲染过程解析 ")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://i.loli.net/2020/03/13/jmCSa7vETuiYxdB.png",alt:"微信图片_20200313172041.png"}})]),v._v(" "),_("ul",[_("li",[_("b",[v._v("解析 HTML")])])]),v._v(" "),_("p",[v._v("在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。")]),v._v(" "),_("ul",[_("li",[_("b",[v._v("计算样式")])])]),v._v(" "),_("p",[v._v("浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。")]),v._v(" "),_("ul",[_("li",[_("b",[v._v("计算图层布局")])])]),v._v(" "),_("p",[v._v("页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。")]),v._v(" "),_("ul",[_("li",[_("b",[v._v("绘制图层")])])]),v._v(" "),_("p",[v._v("在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。")]),v._v(" "),_("ul",[_("li",[_("b",[v._v("整合图层，得到页面")])])]),v._v(" "),_("p",[v._v("最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。")]),v._v(" "),_("h3",[v._v(" 几棵重要的“树” ")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://i.loli.net/2020/03/13/SimKbOuTcnhZLkE.png",alt:"微信图片_20200313172448.png"}})]),v._v(" "),_("ul",[_("li",[_("p",[v._v("DOM 树：解析 HTML 以创建的是 DOM 树（DOM tree ）：渲染引擎开始解析 HTML 文档，转换树中的标签到 DOM 节点，它被称为“内容树”。")])]),v._v(" "),_("li",[_("p",[v._v("CSSOM 树：解析 CSS（包括外部 CSS 文件和样式元素）创建的是 CSSOM 树。CSSOM 的解析过程与 DOM 的解析过程是并行的。")])]),v._v(" "),_("li",[_("p",[v._v("渲染树：CSSOM 与 DOM 结合，之后我们得到的就是渲染树（Render tree ）。")])]),v._v(" "),_("li",[_("p",[v._v("布局渲染树：从根节点递归调用，计算每一个元素的大小、位置等，给每个节点所应该出现在屏幕上的精确坐标，我们便得到了基于渲染树的布局渲染树（Layout of the render tree）。")])]),v._v(" "),_("li",[_("p",[v._v("绘制渲染树: 遍历渲染树，每个节点将使用 UI 后端层来绘制。整个过程叫做绘制渲染树（Painting the render tree）。")])])]),v._v(" "),_("p",[_("b",[v._v("渲染过程说白了，首先是基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。")])]),v._v(" "),_("p",[v._v("之后每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它。")])])}),[],!1,null,null,null);_.default=e.exports}}]);